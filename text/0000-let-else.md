- Feature Name: `let_else`
- Start Date: 2018-08-12
- RFC PR: (leave this empty)
- Rust Issue: (leave this empty)

# Summary
[summary]: #summary

Introduce the `let`/`else` statement.

```rust
// use `let`/`else` for early break.
let Some((mod_id, mod_name)) = find_first_mod_parent(self.map, cursor) else {
    return false;
}

// use `let`/`else` to pick a default value.
let ParamName::Plain(ident) = hir_name else {
    ident = keywords::UnderscoreLifetime.name();
}
let str_name = ident.as_interned_str();
```

# Motivation
[motivation]: #motivation

Solves rightward drift.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

## Grammar

We expand the `let` statement with the following grammar:

<details><summary>

![](let_else_syntax_diagram.png)

</summary>

Generated by <https://lukaslueg.github.io/macro_railroad_wasm_demo/> with the following macro

```rust
macro_rules! let_else {
    (let $pat:pat $(: $ty:ty)?;) => { ... };
    (let $pat:pat $(: $ty:ty)? = $expr:expr;) => { ... };
    (let $pat:pat $(: $ty:ty)? = $non_blk_sfx_expr:expr else $else_block:block) => { ... };
}
```

</details>

To combat the ambiguity with `let x = if a { b } else { c };`,
we restrict the `else` branch must be preceded by a *non-block-suffix expression*.

A *block-suffix expression* is an expression which ends with a block expression like `if` and `for`.
For instance, `loop { break 1; } + 3` is a non-block-suffix expression,
while `2 + loop { break 4; }` is a block-suffix expression.

The easiest way to parse the `let`/`else` statement is to parse the initialize as an expression,
then check the AST to see if it is block-suffix, and prepare to reject the `else` token if so.

<details><summary>Code definition of block-suffix expression</summary>

```rust
fn is_block_suffix_expr(e: &Expr) -> bool {
    match &e.kind {
        If(..)
        | IfLet(..)
        | While(..)
        | WhileLet(..)
        | ForLoop(..)
        | Loop(..)
        | Match(..)
        | Async(..)
        | Catch(..)
        => true,

        Array(..)
        | Call(..)
        | MethodCall(..)
        | Tup(..)
        | Lit(..)
        | Cast(..)
        | Type(..)
        | Block(..)
        | Field(..)
        | Index(..)
        | Path(..)
        | Continue(..)
        | InlineAsm(..)
        | Mac(..)
        | Struct(..)
        | Repeat(..)
        | Paren(..)
        | Try(..)
        => false,

        Box(e)
        | Binary(_, _, e)
        | Unary(_, e)
        | Closure(_, _, _, _, e, _)
        | Assign(_, e)
        | AssignOp(_, _, e)
        | AddrOf(_, e)
        => is_block_suffix_expr(e),

        Range(_, se, _)
        | Break(_, se)
        | Ret(se)
        | Yield(se)
        => se.as_ref().map_or(false, |e| is_block_suffix_expr(e)),
    }
}
```

</details>

<table>
<thead>
<tr><th>Example code<th>Expanded AST
<tbody>
<tr><td>

```rust
let x = y else { z; };
```

<td>let/else statement

* initializer: `y`
* else_block: `z;`

<tr><td>

```rust
let x = if a { y } else { z };
```

<td>let statement

* initializer: `if a { y } else { z }`

<tr><td>

```rust
let x = if a { y } else { z } else { w; };
//                            ^^^^
```

<td>Syntax error, unexpected "else"

<tr><td>

```rust
let x = (if a { y } else { z }) else { w; };
```

<td>let/else statement

* initializer: `(if a { y } else { z })`
* else_block: `w;`

<tr><td>

```rust
let x = loop { y; } else { w; };
//                  ^^^^
```

<td>Syntax error, unexpected "else"

<tr><td>

```rust
let x = { y } else { w; }
```

<td>let/else statement

* initializer: `{ y }`
* else_block: `w;`

<tr><td>

```rust
macro_rules! m {
    () => {
        if a { y }
    }
}
let x = m!() else { z; }
```

<td>let/else statement

* initializer: `{ if a { y } }`
* else_block: `z;`

<tr><td>

```rust
macro_rules! m {
    ($e:expr) => {{
        let x = $e else { w; };
    }}
}
m!(if a { y });
```

<td>let/else statement

* initializer: `{ if a { y } }`
* else_block: `w;`

<tr><td>

```rust
macro_rules! m {
    ($($t:tt)*) => {{
        let x = $($t)* else { w; };
    }}
}
m!(if a { y });
```

<td>let statement

* initializer: `if a { y } else { w; }`

</table>

## Hygiene

In the `let`/`else` statement

```rust
let $pat = $expr else { $else_block }
```

the symbols introduced by `$pat` is *invisible* to `$expr`, but *visible* to `$else_block`.

## Semantic

The `let $pat = $expr else { $block }` statement will be lowered as:

```rust
$(let $bindings_in_scope;)*
match $expr {
    $pat => {
        $($bindings_in_scope = $bindings_in_pat;)*
    }
    _ => {
        $block
    }
}
```

As an example,

```rust
let Some(x) = [1,2,3,4].get(..3) else {
    panic!("totally unexpected!");
}
let &[a, b, 5] = x else {
    println!("unexpected value! resetting to default");
    a = 0;
    b = 0;
}
```

will be lowered as

```rust
let x;
match [1,2,3,4].get(..3) {
    Some(x_0) => { x = x_0; }
    _ => { panic!("totally unexpected!"); }
}

let a;
let b;
match x {
    &[a_0, b_0, 5] => { a = a_0; b = b_0; }
    _ => {
        println!("unexpected value! resetting to default");
        a = 0;
        b = 0;
    }
}
```

To use the bound variable from `let`/`else` statement,
the `else` block must either be diverging or properly initialize all the variables.

```rust
let Some(a) = foo() else {}
let b = a;
//  ^
// error[E0381]: use of possibly uninitialized variable: `a`
```

# Drawbacks
[drawbacks]: #drawbacks

* The ambiguity problem of `let x = if a { b } else { c }` is still not solved.

* There is no way to use the matched value in the `else` block, and thus error information will be lost.
    This was considered an anti-pattern.

# Rationale

## Rejecting all block expressions instead of just `if` expressions

There have been Pre-RFCs about adding [`for`/`then`/`else` expressions][Pre-RFC 8072]
and [`try`/`match` expressions][Issue 50412].
To avoid a silent change of parsed AST with `let a = for i in s { ... } else { ... };`,
this RFC chooses to reject all block expressions.

## Allowing the `else` block to be non-diverging

In [RFC 1303] and Swift's `guard let`/`else` statement,
the `else` block is required to be diverging to ensure the bound variables are indeed initialized.

This RFC places no such requirement since there is strong request from the community to allow
`let`/`else` be used to provide default values.
This RFC relies on the move checker to ensure all variables are initialized.

Some alternatives which often come up are:

1. Return the default values to the bindings:

    ```rust
    let Some(a) = foo() else { 0 };
    // set a = 0 if foo() is None.

    let Foo::Bar(a, b) = foo() else { (5, 6) };
    // set a = 5 and b = 6 on match fail.
    ```

    The problem is this requires the bindings be well-ordered,
    which would be ambiguous with `|` patterns ([RFC 2175]).

    ```rust
    let Ok(&[x, y]) | Err(&[y, x]) = foo() else { (7, 8) }
    // should we set (x, y) = (7, 8) or (y, x) = (7, 8)?
    ```

    This RFC solves the problem by naming `x` and `y` explicitly.

    ```rust
    let Ok(&[x, y]) | Err(&[y, x]) = foo() else {
        x = 7;
        y = 8;
    }
    ```

2. Return a default value compatible with the refuted pattern:

    ```rust
    let Some(a) = foo() else { Some(0) };
    let Foo::Bar(a, b) = foo() else { Foo::Bar(5, 6) };
    ```

    The compiler is supposed to reject incompatible patterns at compile time:

    ```rust
    let Some(a) = foo() else { None };
    // error: cannot match `None` with `Some(_)`
    ```

    But some patterns can only be checked at runtime,
    and thus the compiler needs to conservatively reject this:

    ```rust
    let dv: &[i32] = &[1, 2][..];
    let &[x, y] = foo() else { dv };
    // error: cannot match `dv` with `&[_, _]`
    ```

    This RFC allows user to assert these at runtime:

    ```rust
    let dv: &[i32] = &[1, 2][..];
    let &[x, y] = foo() else {
        x = dv[0];
        y = dv[1];
    }
    ```

## Alternatives




This RFC is a revival of [RFC 1303] \(*Add a `let...else` expression, similar to Swift's `guard let...else`*\)
which was [postponed][c307].




### Refutable let in general

Pro:

* [c426] want to check error conditions and early-return at the start of a function and have the rest of the code be clear and un-indented.

    In my experience this reduces the cognitive load of reading such code.
    The error conditions are out of sight and out of mind while reading the body.
    In the former case the error condition lingers in the form of nesting, and possibly an else block,
    and it only gets worse in many real examples with multiple things to be unwrapped and matched.


### `if !let`

Pro:

Con:

* [c919] It can't be implemented by desugaring, as it has an effect on the entire function, not just the little part it occupies syntactically.
* [c839] This feels too different from if let while at the same time feels like it's very special syntax to solve a very non-general problem.
    This also eats up a part of Rust's "strangeness" budget.
* [c416] I find very surprising that the scope of the bindings is after the thing that defines them, rather than inside like for match and if let.
* [c006] I find it disturbing that this new form of let is actually not introducing a variable.

    ```rust
    if !let Some(a) = x {
        println!("{}", a); // hoops, `a` does not even exist here!
    }
    ```

### `let â€¦ else`

Pro:

Con:

* [c718]: I don't like the idea of having to scan ahead in the program text for else in order to tell whether I should expect the pattern to be irrefutable or not.
* [c297]: I would also change else to something else (maybe otherwise or or), since let Some(a) = if cond {} else {} else {}; may look strange and be error-prone :)

### `unless let`



### Variable Defaulting

Proposal:

* [c266]:

    ```rust
    let Some(a) = x else true; // default value?!
    let Err(string) = err else "no error";
    let Token(TokenLiteral::String(s)) = token else return Err("string token expected");
    ```

* [c310]: I don't like let Some(a) = x else DEFAULT_VALUE; syntax where a is bound to DEFAULT_VALUE, since what happens when someone will write let (a,b) = x else DEFAULT_VALUE; ?



### `else` should be block




[c426]: https://github.com/rust-lang/rfcs/pull/1303#issuecomment-144912426
[c919]: https://github.com/rust-lang/rfcs/pull/1303#issuecomment-144915919
[c839]: https://github.com/rust-lang/rfcs/pull/1303#issuecomment-144919839
[c416]: https://github.com/rust-lang/rfcs/pull/1303#issuecomment-144959416
[c006]: https://github.com/rust-lang/rfcs/pull/1303#issuecomment-144960006
[c266]: https://github.com/rust-lang/rfcs/pull/1303#issuecomment-144975266
[c718]: https://github.com/rust-lang/rfcs/issues/373#issuecomment-58436718
[c310]: https://github.com/rust-lang/rfcs/pull/1303#issuecomment-145074310
[c297]: https://github.com/rust-lang/rfcs/pull/1303#issuecomment-145080297
[c307]: https://github.com/rust-lang/rfcs/pull/1303#issuecomment-183437307

## Prior art

### Previous attempts

* **[RFC issue 373]: Explicit refutable `let`: `let`..`else`**



* **[RFC 1303] â€” Add a `let...else` expression, similar to Swift's `guard let...else`**

    First formal attempt at introducing refutable `let`.

    Initial version used the syntax `if !let $pat = $expr { $block }`.

* **[RFC 2221] â€” Guard Clause Flow Typing**

    Introduces flow-sensitive typing similar to TypeScript.

    Heavily opposed due to added complexity compared with `let`/`else` without adding much benefit,
    and thus FCP-closed.

    ```rust
    if let Err(_) = result {
        // compiler will know `result` must have the shape `Err(_)` here.
        return;
    }
    // compiler will know `result` must have the shape `Ok(_)` here,
    // thus the pattern below is irrefutable.
    let Ok(x) = result;
    ```

[RFC 243]: https://github.com/rust-lang/rfcs/pull/243
[RFC issue 373]: https://github.com/rust-lang/rfcs/issues/373
[RFC 1303]: https://github.com/rust-lang/rfcs/pull/1303
[RFC 2175]: https://github.com/rust-lang/rfcs/pull/2175
[RFC 2221]: https://github.com/rust-lang/rfcs/pull/2221
[Pre-RFC 8072]: https://internals.rust-lang.org/t/for-loop-modifier-blocks/8072
[Issue 50412]: https://github.com/rust-lang/rust/issues/50412
